{
  "hash": "ef476a086a8628c31d7c5e9688f8d83b",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Big Stew: Demonstrating Network Analysis with Mediterranean Microbial Data\"\ndate: 2025-01-30\nauthors:\n  - name: \n      given: Zhehao\n      family: Hu\n    email: hu_zhehao@hotmail.com\n    url: https://zzzhehao.github.io\n    affiliations:\n      - name: Department of Biology, University of Hamburg\n        city: Hamburg\n        country: Germany\n        url: https://www.biologie.uni-hamburg.de/en.html\n    corresponding: true\n  - name: \n      given: \"Jan Moritz\"\n      family: Fehr\n    affiliations:\n      - name: Department of Biology, University of Hamburg\n        city: Hamburg\n        country: Germany\n        url: https://www.biologie.uni-hamburg.de/en.html\ncitation: true\n---\n\n\n\n\n::: {.disclaimer}\n\nThis is a tiny meta-analysis project for demonstration in M. Sc. Biology module *Network Analysis in Ecology and Beyond* offered by Prof. Dr. Jochen Fr√ºnd at [University of Hamburg](https://www.biologie.uni-hamburg.de/en.html). \n\nThe data used is credited to @deutschmann2024 and available in the [original repo](https://github.com/InaMariaDeutschmann/GlobalNetworkMalaspinaHotmix), as well as in [our repo](https://github.com/zzzhehao/MediterraneanMicrobiome).\n\nAnalysis shown was done by Jan Moritz Fehr (Data wrangling, Modularity analysis, NMDS, Bipartite network) and Zhehao Hu (Indices calculation, Null model testing, NMDS). Source code available at [github.com](https://github.com/zzzhehao/MediterraneanMicrobiome).\n\nThe majority of the computation results in this article are stored in RDS files, as they take huge amount of time to execute while maintaining the website. These RDS files are available in the [website branch](https://github.com/zzzhehao/MediterraneanMicrobiome/tree/website-quartoMute). See invisible codes in source file to see where the checkpoints are.\n\nA digital version of the poster for final presentation in course is available [here](https://zzzhehao.github.io/biology-research/community-ecology/MediterraneanMicrobiome/publication/Poster.pdf). \n\nCorrespondence concerning this article should be addressed to [Zhehao Hu](mailto:hu_zhehao@hotmail.com).\n\n:::\n\n::: {.callout-warning}\n\n## Big Stew\n\nLike the title says, this is a very long note with multiple methods. Kindly use TOC on the side to avoid getting lost.\n\n:::\n\n## Ocean Microbiome\n\nWe adopted the data processed and published by @deutschmann2024, and focused on the Mediterranean subset. Thank to the comprehensive record of ecological parameters of the samples, we were able to divide the Mediterranean subset of microbial network into subnetworks according to their depth. The data was originally categorized in 5 layers: \n\n- Surface (**SRF**): 0 - 3 m\n- Epipelagic (**EPI**): 12 - 50 m\n- Deep-Chlorophyll Maximum (**DCM**): 40 - 130 m\n- Mesopelagic (**MES**): 200 - 1000 m\n- Bathypelagic (**BAT**): 1100 - 3300 m\n\nWe have combined EPI and DCM for the sake of simplicity and also because DCM is recognized as part of EPI. EPI is also called as sunlit zone, where solar resource could still be utilized by photosynthesis. As the red light being absorbed faster than the blue light, in MES, also known as twilight zone, there's only dim blue light present, which can not be used for photosynthesis. Which will eventually as well disappear in BAT, at which depth the most area of Mediterranean Sea hits the sea floor.\n\nIn each layer, the species composition besides microorganism is different: in SRF and EPI, phytoplanktons are able to import solar energy into the ecosystem and this  attracts small zooplanktons to feed at this depth. As photosynthesis becomes no longer possible in MES, it is home to many nektons: fishes, squids, larger crustaceans, etc. In BAT, as we approach the sea floor, benthic fauna becomes an important part. Such differences in interaction partners will also affect microorganism communities. But in what extent? Or how are the communities different? Such question can be answered by analyzing the co-occurrence / association network. \n\n@deutschmann2024 has published an Amplicon Sequences Variants (ASV) abundance data, which comprises an abundance matrix in the form that each row represents a sample site and each column represents an OTU (Operational Taxonomic Unit, commonly used in microbiology as proxies for species concept). This matrix directly represents an adjacency matrix for a species-location bipartite network.\n\nFor more information about ocean layers, kindly see [Know Your Ocean](https://www.whoi.edu/know-your-ocean/ocean-topics/how-the-ocean-works/ocean-zones/) from WHOI.\n\n\n::: {.callout-caution appearance=\"minimal\" style=\"font-sze:0.9rem; border-left: none; border: 1px solid var(--clcolor);\" collapse=\"true\"}\n\n## [R Setup]{.cl-sub}\n\n\n\n```r\nlibrary(bipartite)\nlibrary(tidyverse)\nlibrary(vegan)\nlibrary(geomtextpath)\nlibrary(ggpubr)\nlibrary(furrr)\n\npath <- \"MediterraneanMicrobiome/\"\n```\n\n:::\n\n\n\n\n::: {.cell}\n\n:::\n\n\n\n\nLets get the data imported and start with some basic data wrangling:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nASV <- read.delim(paste0(path, \"data/ASV.txt\"), sep = \"\\t\", header = TRUE)\n# ASV = abundance data of OTUs at sampling locations (OTU x location)\nENV <- read.delim(paste0(path, \"data/ENV.txt\"), sep = \"\\t\", header = TRUE)\n# ENV = environmental data of sampling locatoins\nLOC <- read.delim(paste0(path, \"data/Sample_Classification.tsv\"), sep =\"\\t\", header = T)\n# LOC = Location data for sampling locations eg. depth / ocean layer\n```\n:::\n\n\n\n::: {.callout-caution appearance=\"minimal\" style=\"font-sze:0.9rem; border-left: none; border: 1px solid var(--clcolor);\" collapse=\"true\"}\n\n\n\n## [Data wrangling]{.cl-sub}\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndfASV <- as.data.frame(t(ASV))\ntENV <- as.data.frame(t(ENV))\ncolnames(dfASV) <- ASV$ID \ndfASV <- dfASV[-1, ]\n\ndfASV <- dfASV %>% \n  mutate_at(1:5457, as.numeric) %>% # turning abundance data into numeric\n  mutate(Sample=row.names(dfASV))  # adding column with sampling location names \n  # rename(dfASV$name, Sample = name) # naming this column \"Sample\"\n\ncolnames(tENV) <- ENV$ID # renaming the columns after the ID column in the ENV dataset. \ntENV <- tENV[-1, ] # deleting the ID row in the tENV dataframe\ntENV <- tENV %>%\n  mutate(Sample=row.names(tENV)) # adding column with sampling location names\n  # rename(tENV$name, Sample = name) # naming this column \"Sample\"\n\nnew <- left_join(dfASV, LOC, by = NULL) # joining ASV and LOC dataframes\nnew <- left_join(new, tENV, by = NULL) \n```\n:::\n\n\n\n\nSubsetting for mediterranean sample locations:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnew.MS <- new[new[, \"OceanRegion\"] == \"MS\", ] # subsetting for samples from Mediterranean sea (MS)\nsp.MS <- new.MS[, 1:5457] # subsetting only the species abundance part of the MS dataframe\nsp.MS <- sp.MS %>% \n  mutate_at(1:5457, as.numeric) # tuning df into numeric data.\nsp.MS <- sp.MS[, colSums(sp.MS) > 0] # only keeping columns where the sum is > 0. therefore getting rid off all OTUs not found in mediterranean sea\n\nsp.MS <- sp.MS %>%\n  mutate(Sample=new.MS$Sample) \n  # rename(sp.MS$name, Sample = name)\n\nENV.MS <- new.MS[, 5458:5473] # subsetting only location and environmental data of sampling locations in the MS\n\nMS <- left_join( # rejoining species abundance and location / environmental data of MS\n  sp.MS, \n  ENV.MS, \n  by = NULL\n)\n\nab.mtx.ncol <- 3208\n```\n:::\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n\n:::\n\n\n\n\n::: \n\n`MS` is now a dataframe comprising `n = 145` rows as sample sites and `p = 3208` columns of OTU, which stores the abundance data in the form of an adjacency matrix. There are additional 16 columns at the end for ecological data.\n\n## Non-metric Multi-Dimensional Scaling (NMDS)\n\nThe most intuitive way to have an overview on the community is to plot them out, NMDS is the most common way to do this.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\nlibrary(vegan)\n\nset.seed(1)\n\nab.mtx <- as.matrix(MS[, 1:ab.mtx.ncol]) # extract abundance matrix\n```\n:::\n\n\n\n\n### Data Preparation\n\nTaking a brief look at the data, it's very clear that out microbial data is actually largely skewed. There are a few species with extremely high reads, and a vast majority being very low frequent, and almost 85% of the cells in our matrix are zero. \n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nab.mtx[ab.mtx == 0] %>% length() / ab.mtx %>% length()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.8453521\n```\n\n\n:::\n\n```{.r .cell-code}\nmax(ab.mtx)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 59282\n```\n\n\n:::\n\n```{.r .cell-code}\nhist(ab.mtx)\n```\n\n::: {.cell-output-display}\n![](raftmediterranean-microbiome_files/figure-html/unnamed-chunk-8-1.png){fig-align='center' width=672}\n:::\n:::\n\n\n\n\nIt's worth noting that `vegan::metaMDS()`, the function that does the calculation for NMDS, will try to autotransform the data if not specified `autotransform = False`. In our case, considering the extreme skewness of the data and clear pattern, which transforming method to use does not really make big differences. But this is not always true. One should select these methods cautiously. *Hellinger* transformation is one way to reduce the weight of extremely high value. \n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nab.mtx.tf <- decostand(ab.mtx, \"hellinger\")\nmax(ab.mtx.tf)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.63905\n```\n\n\n:::\n:::\n\n\n\n\n### Perform NMDS\n\nEvery community ecologist should be familiar with the basic idea of NMDS, which is dimension reduction. It converts our *n* x *p* matrix into an *n* x *n* dissimilarity matrix. This steps allows flexible decision on how the distances should be calculated. A common choice while dealing with species composition is the Bray-Curtis dissimilarity, as its semi-metric approach takes both presence/absence and abundance information into account. It is also default to `metaMDS()`.\n\nNMDS differs a bit from other ordination methods, like PCA, in handling the distances and calculating axes and coordinates. Its non-metric nature decided that the distance on the final plot does not represents the distances between dataset, but the ranking order. It also therefore, does not try to maximize the variability in axes, which means the axes are completely arbitrary and this technique is mainly used for visualization only [@bakker2024].\n\nBefore starting NMDS, we have to specify ***k***, which gives the number of axes we want to have. NMDS will then take iterative process to adjust the scaling. After each iteration, it calculates a ***stress*** values showing how nice the ordination represents real data. The value ranges from 0 to 1, where 0 means a perfect fit. It however indicates danger for interpreting the ordination already from 0.2. Generally a stress value under 0.1 is considered a good result [@clarke1993; @bakker2024]. \n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nNMDS <- metaMDS(ab.mtx.tf, k=2, autotransform = F, trymax = 50)\n```\n:::\n\n\n\n::: {.callout-caution appearance=\"minimal\" style=\"font-sze:0.9rem; border-left: none; border: 1px solid var(--clcolor);\" collapse=\"true\"}\n\n\n\n## [See the processing result]{.cl-sub}\n\n\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\nRun 0 stress 0.07999079 \nRun 1 stress 0.08285436 \nRun 2 stress 0.07999154 \n... Procrustes: rmse 0.0001703311  max resid 0.001452497 \n... Similar to previous best\nRun 3 stress 0.07999155 \n... Procrustes: rmse 0.0001706899  max resid 0.00145164 \n... Similar to previous best\nRun 4 stress 0.07999154 \n... Procrustes: rmse 0.0001700711  max resid 0.001453166 \n... Similar to previous best\nRun 5 stress 0.08285435 \nRun 6 stress 0.08285435 \nRun 7 stress 0.08285435 \nRun 8 stress 0.08285435 \nRun 9 stress 0.07999154 \n... Procrustes: rmse 0.0001701321  max resid 0.00145255 \n... Similar to previous best\nRun 10 stress 0.07999154 \n... Procrustes: rmse 0.0001702127  max resid 0.001452927 \n... Similar to previous best\nRun 11 stress 0.08285436 \nRun 12 stress 0.08285435 \nRun 13 stress 0.07999079 \n... New best solution\n... Procrustes: rmse 8.647632e-06  max resid 3.669006e-05 \n... Similar to previous best\nRun 14 stress 0.07999154 \n... Procrustes: rmse 0.0001693804  max resid 0.001455979 \n... Similar to previous best\nRun 15 stress 0.07999079 \n... New best solution\n... Procrustes: rmse 3.17566e-06  max resid 1.566341e-05 \n... Similar to previous best\nRun 16 stress 0.07999155 \n... Procrustes: rmse 0.0001701166  max resid 0.001452896 \n... Similar to previous best\nRun 17 stress 0.08285435 \nRun 18 stress 0.07999078 \n... New best solution\n... Procrustes: rmse 5.149409e-06  max resid 2.555982e-05 \n... Similar to previous best\nRun 19 stress 0.08285435 \nRun 20 stress 0.08285435 \n*** Best solution repeated 1 times\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nNMDS\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\nCall:\nmetaMDS(comm = ab.mtx.tf, k = 2, trymax = 50, autotransform = F) \n\nglobal Multidimensional Scaling using monoMDS\n\nData:     ab.mtx.tf \nDistance: bray \n\nDimensions: 2 \nStress:     0.07999078 \nStress type 1, weak ties\nBest solution was repeated 1 time in 20 tries\nThe best solution was from try 18 (random start)\nScaling: centring, PC rotation, halfchange scaling \nSpecies: expanded scores based on 'ab.mtx.tf' \n```\n\n\n:::\n:::\n\n\n\n\n:::\n\n### NMDS Plot using `{ggplot2}`\n\nThere are several plotting functions from `{vegan}`, but since we were trying to make a fancy poster, I brought out my old script to make fully controlled plot with `{ggplot2}`.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Extract coordinates\nsiteCoord <- as_tibble(scores(NMDS)$sites)\nspCoord <- as_tibble(scores(NMDS)$species)\n\n# Import aesthetics setting\nsource(paste0(path, \"analysis/AES.R\"))\n\n# Plot the species\np.NMDS.sp <- ggplot() +\n    geom_point(data = spCoord, aes(x = NMDS1, y = NMDS2), size = 2, shape = 3, color = \"grey\", alpha = 0.25) +\n    aes_ACTCP_ggplot() +\n    theme(aspect.ratio = 1) +\n    coord_equal()\n\np.NMDS.sp\n```\n\n::: {.cell-output-display}\n![](raftmediterranean-microbiome_files/figure-html/unnamed-chunk-13-1.png){width=672}\n:::\n:::\n\n\n\n\nAs simple as that, we have our species plotted. But we are not really interested in individual species, instead, the community at different sites. For that purpose, we have to first pass the environmental data of each site into `siteCooord`.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Extract environmental data, combine DCM with EPI\nenv <- MS[, (ab.mtx.ncol+1):ncol(MS)] %>% \n    mutate(layer = case_when(layer == \"DCM\" ~ \"EPI\", .default = layer))\nsiteCoord_env <- cbind(siteCoord, env)\n\n# Order the layer \nsiteCoord_env_ordered <- siteCoord_env %>% mutate(layer = factor(layer, levels = c(\"SRF\", \"EPI\", \"MES\", \"BAT\")))\n```\n:::\n\n\n\n\nThen we can plot them as usual:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Define colors for the layers\ndepth.colors <- c(\n    \"SRF\" = \"#6CCCD6\",\n    \"EPI\" = \"#007896\", \n    \"MES\" = \"#004359\",\n    \"BAT\" = \"#001C25\"\n)\n\ndepth.shapes <- c(\n    \"SRF\" = 15,\n    \"EPI\" = 16, \n    \"MES\" = 17,\n    \"BAT\" = 18\n)\n\np.NMDS.st <- ggplot() +\n    geom_point(data = siteCoord_env_ordered, aes(x = NMDS1, y = NMDS2, color = layer, shape = layer), size = 3.5, alpha = 0.8) +\n    aes_ACTCP_ggplot() +\n    theme(aspect.ratio = 1) +\n    scale_color_manual(values = depth.colors) +\n    scale_shape_manual(values = depth.shapes) +\n    guides(color = guide_legend(\"Layer\"), fill = \"none\", shape = guide_legend(\"Layer\"))\n\np.NMDS.st\n```\n\n::: {.cell-output-display}\n![](raftmediterranean-microbiome_files/figure-html/unnamed-chunk-15-1.png){width=672}\n:::\n:::\n\n\n\n\nNow, this is telling us more information, we can see that sample sites from the same layer tend to cluster together. A common way to show such categorical data in NMDS is to draw a convex hull on those clusters. \n\n### NMDS Hullplot using `{ggplot2}` \n\nThe basic idea is simply use `chull()` to identify the points from the same cluster that are on the border of the hull and draw a polygon using those points. But the problem is that we have some outliers here, especially from MES (those two neighboring BAT and SRF). Those points would surely become the one defining the convex hull, and makes the hull covering much more area than the cluster really does. \n\nTo address this, I additionally calculate the euclidean centroids of each cluster and filter out outliers by comparing their distances to the centroids with the median distances to the centroids from all points within the same cluster. Those points that has a distance larger than a threshold calculated from median distance with defined multiplier will not be included.\n\n\n::: {.callout-caution appearance=\"minimal\" style=\"font-sze:0.9rem; border-left: none; border: 1px solid var(--clcolor);\" collapse=\"true\"}\n\n\n\n## [See the result if we do not exclude those points]{.cl-sub}\n\n\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](raftmediterranean-microbiome_files/figure-html/unnamed-chunk-16-1.png){width=672}\n:::\n:::\n\n\n\n\n:::\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Calculate the coordinates of the hull border\noutliner <- function(coord, group_var,  threshold_factor = 2, threshold_func = median) {\n    centroid <- colMeans(coord[, c(1, 2)])\n    centroids <- matrix(c(rep(centroid[1], nrow(coord)), rep(centroid[2], nrow(coord))), ncol = 2)\n    \n    # Euclidean distances\n    coord$distances <- sqrt(rowSums((coord[, c(1, 2)] - centroids)^2))\n\n    # Set threshold\n    threshold <- threshold_factor * threshold_func(coord$distances)\n\n    # filter out points with distance larger than threshold\n    coord_in <- coord[coord$distances <= threshold, ]\n\n    outline_indices <- chull(coord_in[, c(1, 2)])\n\n    return(list(\n        borders = coord_in[outline_indices, ], \n        centroid = c(centroid, group = group_var[[1]])\n    ))\n}\n```\n:::\n\n\n\n\n`threshold_factor` controls how conservative or inclusive the convex hull should be drawn. Then we apply this process to each category and extract the hull border coordinatees for ggplot.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Using ordered factor from `siteCoord_env_ordered` can't successfully pass the layer name through the pipeline\nlayer.siteCoord <- siteCoord_env %>% \n    group_by(layer) %>%\n    group_map(~ outliner(.x, .$layer), .keep = T) %>% \n    `names<-`(group_keys(siteCoord_env %>% group_by(layer))[[1]]) %>%\n    do.call(what = rbind, args = .) %>%\n    as.data.frame()\n\n# Extract border and centroid coordinates\nborders.pCoord <- layer.siteCoord[[\"borders\"]] %>% bind_rows()\ncentroids.pCoord <- layer.siteCoord[[\"centroid\"]] %>% bind_rows() %>% mutate(NMDS1 = as.numeric(NMDS1), NMDS2 = as.numeric(NMDS2))\n\np.NMDS.st.hull <- p.NMDS.st +\n    geom_polygon(data = borders.pCoord, aes(x = NMDS1, y = NMDS2, fill = layer), alpha = 0.5) + # hull\n    geom_text(data = centroids.pCoord, aes(x = NMDS1, y = NMDS2, label = group)) +\n    scale_fill_manual(values = depth.colors) \n\np.NMDS.st.hull\n```\n\n::: {.cell-output-display}\n![](raftmediterranean-microbiome_files/figure-html/unnamed-chunk-18-1.png){width=672}\n:::\n:::\n\n\n\n\nThis is one of the clearest NMDS I've ever plotted. Each layer forms a cluster that does not have much overlap with others, except EPI and SRF, which also make sense, because even microorganism in SRF might have different interacting partners than the rest of EPI, the environmental condition and the general species compositions, in particular functionally, should be very similar. This is also reflected by SRF on the far side of EPI with the largest distances to MES or BAT. \n\nThe space between MES and EPI, although they are not encapsulated by any of both, still reflects kind of \"bridge\" section, probably at which depth that both layers meet each other. There's a numerical depth data in `env`, which is principally continuous data complementing our layer categories. While we use hull plot to visualize categeories in NMDS, we can use contour line to visualize continuous variables. \n\n### Fitting smooth surface\n\nIf we imagine the variables we want to display as the third dimension of our points on NMDS, visualize the variables becomes generally visualize a 3-dimensional structure on our 2-D plot, one of whose answer is to fit the surface on our plot using `vegan::ordisurf()`.\n\nThe way to extract contour line from `vegan::ordisurf()` and the function `extract.xyz()` are credited to [Christopher Chizinski's post](https://chrischizinski.github.io/rstats/ordisurf/).\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(geomtextpath)\nextract.xyz <- function(obj) {\n    print(obj)\n  xy <- expand.grid(x = obj$grid$x, y = obj$grid$y)\n  xyz <- cbind(xy, c(obj$grid$z))\n  names(xyz) <- c(\"x\", \"y\", \"z\")\n  return(xyz)\n}\n\ndepth.surf <- ordisurf(NMDS, env$depth, permutation = 999, na.rm = T, plot = F)\ndepth.contour <- extract.xyz(obj = depth.surf)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\nFamily: gaussian \nLink function: identity \n\nFormula:\ny ~ s(x1, x2, k = 10, bs = \"tp\", fx = FALSE)\n\nEstimated degrees of freedom:\n7.84  total = 8.84 \n\nREML score: 1057.237     \n```\n\n\n:::\n\n```{.r .cell-code}\np.NMDS.st.hull.cont <- p.NMDS.st.hull +\n    geom_textcontour(data = depth.contour, aes(x, y, z = z), color = \"#c4438c\") \n\np.NMDS.st.hull.cont\n```\n\n::: {.cell-output-display}\n![](raftmediterranean-microbiome_files/figure-html/unnamed-chunk-19-1.png){width=672}\n:::\n:::\n\n\n\n\nThe depth just explained the cluster really well, and we see those points between MES and EPI are exactly around the transition depth.\n\nBut, what we did so far was basic descriptive work in community ecology. We still want to take a look into the community structure. \n\n## Network Indices\n\nSince our ASV abundance data is representing a co-occurrence relationships between species at different site, the species~site matrix is technically an adjacency matrix of a species~site bipartite network. Once we consider them as a network, we could subset them according to the water layer, and calculare indices respectively for comparison. To clarify, we are taking slices while subsetting the network, it actually results in several individual subnetworks, instead of multiplex or multilayer networks. \n\n### Extract Subnetworks\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\n\nweb.list <- list()\nex.LUT <- list(\n    \"SRF\" = c(\"SRF\"),\n    \"EPI\" = c(\"DCM\", \"EPI\"),\n    \"MES\" = c(\"MES\"),\n    \"BAT\" = c(\"BAT\"))\n\nfor (i in 1:length(ex.LUT)) {\n    web.list[[names(ex.LUT[i])]] <- MS %>% \n        filter(layer %in% ex.LUT[[i]]) %>% \n        dplyr::select(all_of(1:ab.mtx.ncol)) %>% \n        as.matrix()\n} # I couldn't figure out how to do this job with {purrr} while also assigning names to the matrices. Please contact me if you know how.\n\nweb.parent <- MS %>% \n    dplyr::select(all_of(1:ab.mtx.ncol)) %>% \n    as.matrix()\n```\n:::\n\n\n\n\n`web.list` is now a list of 5 matrices and each of them represents a network. Take a look at the reads in each network:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmap_df(web.list, ~ data.frame(reads = sum(.x), ratio = round(sum(.x)/sum(web.parent), 2)), .id = \"web\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  web   reads ratio\n1 SRF 1349540  0.12\n2 EPI 2672831  0.24\n3 MES 4265231  0.38\n4 BAT 3037200  0.27\n```\n\n\n:::\n:::\n\n\n\n::: {.callout-caution appearance=\"minimal\" style=\"font-sze:0.9rem; border-left: none; border: 1px solid var(--clcolor);\" collapse=\"true\"}\n\n\n\n## [See structure of `web.list`]{.cl-sub}\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr(web.list)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nList of 4\n $ SRF: num [1:19, 1:3208] 0 0 0 0 0 0 0 0 0 0 ...\n  ..- attr(*, \"dimnames\")=List of 2\n  .. ..$ : NULL\n  .. ..$ : chr [1:3208] \"Euk_3\" \"Euk_5\" \"Euk_8\" \"Euk_12\" ...\n $ EPI: num [1:39, 1:3208] 0 0 0 0 0 0 0 0 0 0 ...\n  ..- attr(*, \"dimnames\")=List of 2\n  .. ..$ : NULL\n  .. ..$ : chr [1:3208] \"Euk_3\" \"Euk_5\" \"Euk_8\" \"Euk_12\" ...\n $ MES: num [1:52, 1:3208] 55 0 0 0 0 0 0 0 0 0 ...\n  ..- attr(*, \"dimnames\")=List of 2\n  .. ..$ : NULL\n  .. ..$ : chr [1:3208] \"Euk_3\" \"Euk_5\" \"Euk_8\" \"Euk_12\" ...\n $ BAT: num [1:35, 1:3208] 1299 0 0 0 56 ...\n  ..- attr(*, \"dimnames\")=List of 2\n  .. ..$ : NULL\n  .. ..$ : chr [1:3208] \"Euk_3\" \"Euk_5\" \"Euk_8\" \"Euk_12\" ...\n```\n\n\n:::\n:::\n\n\n\n\n:::\n\n### Calculate Indices\n\n`{bipartite}` provides calculation for various indices at different level. Kindly see [Vignette, section 5](https://cran.r-project.org/web/packages/bipartite/vignettes/Intro2bipartite.pdf) for details. We have chosen some indices that we are interested in:\n\n- Connectance: \n- Linkage density: \n- Shannon diversity: \n- Interaction evenness: \n- Togetherness: \n- Network wide specialization index $H^{'}_2$:\n- Specialization asymmetry:\n\nI wrote a function that can apply the indices calculation to all matrices in a list and then summarize them in a data.frame. I also encapsulated them in parallel process (`{furrr}` package) to accelerate computation. Nonetheless, computing SA still consumed a large amount of time (1.5 hour on my machine), I have therefore dropped it from further analysis. \n\n```r\nlibrary(bipartite)\nlibrary(tidyverse)\nlibrary(furrr)\nlibrary(ggpubr)\n\nnetwork.indices <- c(\"connectance\", \"linkage density\", \"Shannon diversity\", \"interaction evenness\", \"togetherness\", \"H2\", \"SA\", \"NODF\")\n\nplan(multisession, workers = 4)\n\nindex.networklvl <- function(web.mtx.list, index.vec) {\n    network.res <- future_map(web.mtx.list, \\(x) networklevel(x, index = index.vec, intereven = \"sum\"), .options = furrr_options(seed = TRUE)) %>% \n        bind_rows %>% \n        as.data.frame() %>% \n        `rownames<-`(names(web.mtx.list))\n    return(network.res)\n}\n\nsystem.time({\n    index.network.res <- index.networklvl(web.list, network.indices) %>% mutate(layer = rownames(.))\n})\n```\n\n\n\n\n\n\n::: {.cell}\n::: {.cell-output-display}\n`````{=html}\n<div data-pagedtable=\"false\">\n  <script data-pagedtable-source type=\"application/json\">\n{\"columns\":[{\"label\":[\"layer\"],\"name\":[1],\"type\":[\"chr\"],\"align\":[\"left\"]},{\"label\":[\"connectance\"],\"name\":[2],\"type\":[\"dbl\"],\"align\":[\"right\"]},{\"label\":[\"specialisation asymmetry\"],\"name\":[3],\"type\":[\"dbl\"],\"align\":[\"right\"]},{\"label\":[\"linkage density\"],\"name\":[4],\"type\":[\"dbl\"],\"align\":[\"right\"]},{\"label\":[\"Shannon diversity\"],\"name\":[5],\"type\":[\"dbl\"],\"align\":[\"right\"]},{\"label\":[\"interaction evenness\"],\"name\":[6],\"type\":[\"dbl\"],\"align\":[\"right\"]},{\"label\":[\"H2\"],\"name\":[7],\"type\":[\"dbl\"],\"align\":[\"right\"]},{\"label\":[\"togetherness.HL\"],\"name\":[8],\"type\":[\"dbl\"],\"align\":[\"right\"]},{\"label\":[\"togetherness.LL\"],\"name\":[9],\"type\":[\"dbl\"],\"align\":[\"right\"]},{\"label\":[\"NODF\"],\"name\":[10],\"type\":[\"dbl\"],\"align\":[\"right\"]}],\"data\":[{\"1\":\"SRF\",\"2\":\"0.3676665\",\"3\":\"-0.2982932\",\"4\":\"66.91691\",\"5\":\"7.580179\",\"6\":\"0.8458731\",\"7\":\"0.2385453\",\"8\":\"0.12367606\",\"9\":\"0.3712104\",\"10\":\"53.59321\"},{\"1\":\"EPI\",\"2\":\"0.2730526\",\"3\":\"-0.2546861\",\"4\":\"83.25154\",\"5\":\"8.560462\",\"6\":\"0.8710558\",\"7\":\"0.2904024\",\"8\":\"0.10038103\",\"9\":\"0.2962359\",\"10\":\"39.89817\"},{\"1\":\"MES\",\"2\":\"0.2268262\",\"3\":\"-0.2221361\",\"4\":\"84.85583\",\"5\":\"8.744310\",\"6\":\"0.8483045\",\"7\":\"0.2951209\",\"8\":\"0.08540130\",\"9\":\"0.2472512\",\"10\":\"35.45515\"},{\"1\":\"BAT\",\"2\":\"0.2736169\",\"3\":\"-0.1812716\",\"4\":\"57.37288\",\"5\":\"7.963473\",\"6\":\"0.8246421\",\"7\":\"0.2324459\",\"8\":\"0.08139021\",\"9\":\"0.3472697\",\"10\":\"44.57840\"}],\"options\":{\"columns\":{\"min\":{},\"max\":[10]},\"rows\":{\"min\":[10],\"max\":[10]},\"pages\":{}}}\n  </script>\n</div>\n`````\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n#### Simulate Null models: swap web ####\n\n# swap.bootstrap <- 300\n\n# plan(multisession, workers = 4)\n# \n# time.test <- system.time({\n#     null.models <- future_map(web.list[1:length(web.list)-1], \\(x) nullmodel(x, N = 1, method = \"swap.web\"), .options = furrr_options(seed = TRUE))\n# })\n# \n# time.estimate <- swap.bootstrap * time.test[3]\n# time.estimate <- paste0(floor(time.estimate / 3600), ' hour ', floor(time.estimate / 60 - 60 * floor(time.estimate / 3600)), ' min ', floor(time.estimate %% 60), ' s')\n\n# print(paste0(\"[Info] One simulation took \", time.test[3], \" s, \", swap.bootstrap, \" bootstrap replicates are estimated for \", time.estimate))\n\n# print(paste0(\"[Info] Start simulating null models: \", Sys.time()))\n\n# null.models <- future_map(web.list[1:length(web.list)-1], \\(x) nullmodel(x, N = swap.bootstrap, method = \"swap.web\"), .options = furrr_options(seed = TRUE))\n# saveRDS(null.models, \"data/NullModels_list.rds\")\n# null.models <- readRDS(\"data/NullModels_list.rds\")\n\n# print(paste0(\"[Info] End simualting null models: \", Sys.time()))\n# print(paste0(\"[Info] Calculating indices for null models: \", Sys.time()))\n# \n# null.model.indices <- map(null.models, \\(x) {\n#     index.networklvl(x, network.indices)\n# })\n# \n# print(paste0(\"[Info] End of calculating indices for null models: \", Sys.time()))\n\n#### Simulate Null models: r2d ####\n\n# r2d.bootstrap <- 300\n\n# plan(multisession, workers = 4)\n# \n# time.test <- system.time({\n#     null.models <- future_map(web.list[1:length(web.list)-1], \\(x) nullmodel(x, N = 1), .options = furrr_options(seed = TRUE))\n# })\n# \n# time.estimate <- r2d.bootstrap * time.test[3]\n# time.estimate <- paste0(floor(time.estimate / 3600), ' hour ', floor(time.estimate / 60 - 60 * floor(time.estimate / 3600)), ' min ', floor(time.estimate %% 60), ' s')\n\n# print(paste0(\"[Info] One simulation took \", round(time.test[3], digit = 2), \" s, \", r2d.bootstrap, \" bootstrap replicates are estimated for \", time.estimate))\n# \n# print(paste0(\"[Info] Start simulating null models: \", Sys.time()))\n\n# null.models.r2d <- future_map(web.list[1:length(web.list)-1], \\(x) nullmodel(x, N = r2d.bootstrap), .options = furrr_options(seed = TRUE))\n# saveRDS(null.models.r2d, \"data/NullModels_list_r2d.rds\")\n# null.models.r2d <- readRDS(\"data/NullModels_list_r2d.rds\")\n\n# print(paste0(\"[Info] End simualting null models: \", Sys.time()))\n# print(paste0(\"[Info] Calculating indices for null models: \", Sys.time()))\n# \n# null.model.indices.r2d <- map(null.models.r2d, \\(x) {\n#     index.networklvl(x, network.indices)\n# })\n# \n# print(paste0(\"[Info] End of calculating indices for null models: \", Sys.time()))\n\n### calculate p-value ####\n\n# null.model.indices.long <- map(c(1:length(null.model.indices.r2d)), \\(x) {\n#     null.model.indices[[x]] %>%\n#         mutate(layer = names(null.model.indices)[x])\n# }) %>% bind_rows()\n\n# index <- \"togetherness.HL\"\n# null.model.indices.long %>% filter(layer == \"MES\") %>% dplyr::select(all_of(index)) %>% .[[1]] %>% hist()\n# abline(v=index.network.res[index][[2]][1], col=\"red\", lwd=2)\n```\n:::\n\n\n\n\nPlot the indices:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot.df.index <- index.network.res %>%\n    mutate(\n        \"Linkage density\" = `linkage density`/max(`linkage density`),\n        \"Shannon diversity\" = `Shannon diversity`/max(`Shannon diversity`),\n        \"Interaction evenness\" = `interaction evenness`,\n        # \"Interaction strength asymmetry\" = `interaction strength asymmetry`,\n        \"Species togetherness\" = togetherness.HL,\n        \"Specialisation asymmetry\" = `specialisation asymmetry` + 1,\n        \"NODF\" = NODF/max(NODF),\n        \"layer\" = layer,\n        .keep = \"unused\") %>%\n    dplyr::select(-c(\"togetherness.LL\")) %>%\n    pivot_longer(., cols = -c(\"layer\"))\n\nlabel <- c(\n    \"BAT\" = \"Bathypelagic\",\n    \"MES\" = \"Mesopelagic\",\n    \"EPI\" = \"Epipelagic\",\n    \"SRF\" = \"Surface\",\n    \"Whole\" = \"Whole\"\n)\n\npalette <- c(\"#2B502D\", \"#FFC21F\", \"#E00302\", \"#D261D5\")\nindex.network.clrs <- grDevices::colorRampPalette(palette)(n = length(unique(plot.df.index$name)))\nnames(index.network.clrs) <- unique(plot.df.index$name)\n\nplot.list <- map(unique(plot.df.index$layer), \\(x) {\n    plot <- plot.df.index %>% \n        filter(layer == x) %>%\n        ggplot() +\n        geom_segment(aes(x = name, xend = name, y = 1, yend = 0), color = \"#CCC\", linewidth = 8, alpha = 0.3, lineend = \"round\") +\n        geom_point(aes(x = name, y = value, color = name), size = 8) +\n        aes_ACTCP_ggplot(use = \"theme_tp_b\") +\n        theme(\n            aspect.ratio = 1,\n            # axis.text.x = element_text(color = \"black\", angle = 90, hjust = 1, vjust = 0.5),\n            axis.text.x = element_blank(),\n            axis.text.y = element_blank(),\n            panel.background = element_blank(),\n            legend.position = \"none\",\n            axis.title.y = element_text(color = \"black\", size = 18),\n        ) +\n        labs(x = '', y = '') +\n        scale_color_manual(values = index.network.clrs)\n    ggsave(filename = paste0(path, \"plots/index_\", label[x], \".svg\"), plot = plot, units = \"cm\", height = 8, width = 8)\n    return(plot)\n})\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nplot.index.legend <-\n    plot.df.index %>%\n    filter(layer == \"BAT\") %>%\n    ggplot() +\n    geom_point(aes(x = name, y = 0, color = name), size = 5) +\n    scale_x_discrete(position = \"top\") +\n    coord_flip() +\n    aes_ACTCP_ggplot() +\n    scale_color_manual(values = index.network.clrs) +\n    theme(\n        axis.text.x = element_blank(),\n        axis.text.y = element_text(angle = 0, hjust = 0, vjust = 0.5, color = \"black\", size = 16),\n        panel.background = element_blank(),\n        aspect.ratio = 7,\n        legend.position = 'none'\n    ) +\n    labs(x = '', y = '') +\n    ylim(c(-0.1,0.1))\n```\n:::\n\n::: {#fig-indices layout=\"[[1,1,1],[1,2]]\"} \n\n![Bathypelagic](/biology-research/community-ecology/MediterraneanMicrobiome/plots/index_Bathypelagic.svg) \n\n![Mesopelagic](/biology-research/community-ecology/MediterraneanMicrobiome/plots/index_Mesopelagic.svg) \n\n![Epipelagic](/biology-research/community-ecology/MediterraneanMicrobiome/plots/index_Epipelagic.svg) \n\n![Surface](/biology-research/community-ecology/MediterraneanMicrobiome/plots/index_Surface.svg) \n\n![Index Legends](/biology-research/community-ecology/MediterraneanMicrobiome/plots/index_legend.svg) \n\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nplot.index.legend <-\n    plot.df.index %>%\n    filter(layer == \"BAT\") %>%\n    ggplot() +\n    geom_point(aes(x = name, y = 0, color = name), size = 5) +\n    scale_x_discrete(position = \"top\") +\n    coord_flip() +\n    aes_ACTCP_ggplot() +\n    scale_color_manual(values = index.network.clrs) +\n    theme(\n        axis.text.x = element_blank(),\n        axis.text.y = element_text(angle = 0, hjust = 0, vjust = 0.5, color = \"black\", size = 16),\n        panel.background = element_blank(),\n        aspect.ratio = 7,\n        legend.position = 'none'\n    ) +\n    labs(x = '', y = '') +\n    ylim(c(-0.1,0.1))\n```\n:::\n\n::: {.cell}\n\n:::\n\n\n\n\n\n<!-- ## Bipartite (species ~ layer) network\n\nThis part constructs the bipartite network showing microorganism in orders on the left side, and the layers in which they occure.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nMS$layer <- str_replace_all(MS$layer, \"DCM\", \"EPI\") \n\nBAT <- MS[MS[, \"layer\"] == \"BAT\", ]\nMES <- MS[MS[, \"layer\"] == \"MES\", ]\nEPI <- MS[MS[, \"layer\"] == \"EPI\", ]\nSRF <- MS[MS[, \"layer\"] == \"SRF\", ]\n```\n:::\n\n\n\n\nOTUxtaxdata:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Step 1: Pivot the species columns to longer format\nlong_df <- MS %>%\n  pivot_longer(\n    cols = 1:3208, # Adjust to match your species column names\n    names_to = \"OTU\",\n    values_to = \"Observations\"\n  )\n\n# Step 2: Filter rows where Observations > 0 (species were observed)\nlong_df <- long_df %>%\n  filter(Observations > 0) %>%\n  select(OTU, layer, OceanRegion, Observations) # Keep only OTU and Layer columns\n\n# Step 3: Remove duplicates to ensure unique OTU-Layer combinations\ndistinct_df <- long_df %>%\n  distinct()\n\ntaxa_LUT <- data.frame(OTU = names(MS[1:ab.mtx.ncol]))\n\nprok_taxa <- read.csv(\"data/Prok_taxdata.txt\", sep = \"\\t\", header = TRUE)\n\nprok_taxa <- prok_taxa %>% \n    mutate(OTU = gsub(pattern = \"_ASV_\", replacement = \"_\", x = .$ID)) %>%\n    mutate(Genus = Genus_SILVA, Family = Family_SILVA, Order = Order_SILVA, Class = Class_SILVA, Phylum = Phylum_SILVA, Kingdom = Kingdom_SILVA)\n\neuk_taxa <- read.csv(\"data/Euk_taxdata.txt\", sep = \"\\t\", header = TRUE)\neuk_taxa <- euk_taxa %>% \n    mutate(OTU = gsub(pattern = \"_ASV_\", replacement = \"_\", x = .$ID)) %>%\n    mutate(Genus = Genus_pr2, Family = Family_pr2, Order = Order_pr2, Class = Class_pr2, Division = Division_pr2, Supergroup = Supergroup_pr2, Kingdom = Kingdom_pr2)\n\nall_taxa <- bind_rows(euk_taxa, prok_taxa)\n\ntaxa_LUT <- left_join(taxa_LUT, all_taxa)\ntaxa_LUT <- select(taxa_LUT, OTU, Genus, Family, Order, Class, Division, Supergroup, Kingdom, Phylum)\n\nOTUxtax <- left_join(distinct_df, taxa_LUT)\n\nOTUxlayer <- frame2webs(OTUxtax, varnames = c(\"layer\", \"Order\", \"OceanRegion\", \"Observations\"))\n\nn_OTU <- ncol(OTUxlayer[[1]])\nOTU.abundance <- colSums(OTUxlayer[[1]])\nnames(OTU.abundance) <- colnames(OTUxlayer[[1]])\n\nlayer.colors <- c(\n  #\"DCM\" = \"forestgreen\",\n  \"BAT\" = \"#253494\", \n  \"MES\" = \"#2C7FB8\",\n  \"EPI\" = \"#41B6C4\", \n  \"SRF\" = \"#7FCDBB\"\n)\n\nhigher_color <- as.data.frame(taxa_LUT$Order)\nhigher_color <- higher_color %>%\n  mutate(Kingdom = taxa_LUT$Kingdom)\nhigher_color <- unique(higher_color)\nhigher_color <- na.omit(higher_color)\n\nOTU_colors <- c(\n  \"Eukaryota\" = \"brown\",\n  \"Archaea\" = \"khaki\",\n  \"Bacteria\" = \"orange\"\n)\n\nhigher_color$color <- OTU_colors[higher_color$Kingdom] # Adding a color column to the dataframe MS\n\ndfOTUxlayer <- as.data.frame(OTUxlayer[[1]])\ndfOTUxlayer <- as.data.frame(t(dfOTUxlayer))\ndfOTUxlayer <- dfOTUxlayer %>%\n  mutate('taxa_LUT$Order' = rownames(dfOTUxlayer))\n\nstr(dfOTUxlayer)\nstr(higher_color)\n\nhigher_color <- left_join(x=dfOTUxlayer, y=higher_color)\nsorted_higher_color <- higher_color[order(higher_color$color), ]\nsort <- sorted_higher_color$'taxa_LUT$Order'\nh.col <- sorted_higher_color$color\n\n\nlayer_abundances <- c(rep(1000, times=5))\nnames(layer_abundances) <- rownames(OTUxlayer[[1]])\n\nOTUxlayer[[1]] <- OTUxlayer[[1]][c(\"BAT\", \"MES\", \"EPI\", \"SRF\"),]\nOTUxlayer[[1]] <- OTUxlayer[[1]][, c(sort)]\n\nplotweb_v2(OTUxlayer[[1]], text_size = 0.1, spacing = \"auto\", horizontal = TRUE, box_size = 0.075, sorting = \"cca\", curved_links = TRUE, link_alpha = 0.5, higher_abundances = OTU.abundance, lower_color = layer.colors,  link_color = \"lower\",\n           higher_color = h.col, scaling = \"absolute\")\n```\n:::\n\n\n\n\n## Module analysis\n\nHere we creat modules for the entire mediterranean sea or the depth layers. We extract only the abundance data from `MS`.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nMS.web <- as.matrix(MS[,1:3208]) \n```\n:::\n\n\n\n\nFollowing line will computing modules for entire mediterranean sea, although it would take considerable amount of time, so we have included the compute result from our analysis.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmoduleweb <- computeModules(MS.web)\nsaveRDS(\"data/MSmoduleweb.rds\")\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nmoduleweb <- readRDS(\"data/MSmoduleweb.rds\")\n```\n:::\n\n\n\n\nWe could use heat map to see the association of the network module and depth layer, which agree with each other in general.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nloc.modules <- moduleweb@modules[-1, -c(1,2) ]\nloc.modules <- loc.modules[, 1:145]\ncolnames(loc.modules) <- MS$Sample\nrownames(loc.modules) <- c(\"Module 1\", \"Modlue 2\", \"Module3\")\nloc.modules[loc.modules > 0] <- 1\nloc.modules <- as.data.frame(t(loc.modules))\nloc.modules <- loc.modules %>%\n  mutate(Depth = MS$layer)\nsum.modules <- summarise(loc.modules, .by=\"Depth\", across(1:3, sum))\nrownames(sum.modules) <- sum.modules$Depth\nsum.modules <- sum.modules[ , 2:4]\nsum.modules <- as.matrix(sum.modules)\n\nheatmap(sum.modules, Rowv = NA, Colv = NA)\n```\n:::\n\n\n\n\n## NMDS\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nNMDS1 <- metaMDS(MS[,1:3208], k=2)\n\n# plot(NMDS1)\ntreat=c(MS$layer)\n# ordispider(NMDS1,groups=treat)\n\n#plotting with ggvegan\nlibrary(ggvegan)\n# library(ggplot2)\n# autoplot(NMDS1)\n\n#full control with fortified ordination output\nfort<-fortify(NMDS1)\nhab <- as.data.frame(as.factor(MS$layer))\nnames(hab) <- c(\"depth\")\n#transform habitat into factors:\n\nadonis2(sp.MS[1:3208]~depth,data=hab)\n#output similar to anova, gives an output of group means for species abundances within each of the classes\n#habitat R2 level is what was explained with adonis, Residual R2 is what was not explained with this adonis. \ndepth.colors <- c(\n  #\"DCM\" = \"forestgreen\",\n  \"BAT\" = \"#7FC97F\",\n  \"MES\" = \"#BEAED4\",\n  \"EPI\" = \"#FDC086\",\n  \"SRF\" = \"#FFFF99\"\n)\np3<-ggplot() +\n  geom_point(data = subset(fort, score == 'sites'),\n             mapping = aes(x = NMDS1, y = NMDS2, colour=hab$depth),\n             alpha=0.8)+\n  geom_segment(data = subset(fort,score == 'species'),\n               mapping = aes(x = 0, y = 0, xend = NMDS1, yend = NMDS2),\n               arrow = arrow(length = unit(0.015, \"npc\"),\n                             type=\"closed\"),\n               colour=\"darkgray\",\n               size =0, #changing this to 0 keeps the scaling but doesnt show lines/data\n               alpha = 0)+\n  geom_abline(intercept = 0, slope = 0, linetype=\"dashed\", linewidth=0.8,colour=\"gray\")+\n  geom_vline(aes(xintercept=0), linetype=\"dashed\", linewidth=0.8,colour=\"gray\")+\n  theme(\n                panel.background = element_rect(color = \"white\", fill = \"transparent\"),\n                axis.text = element_text(color = \"white\"),\n                legend.text = element_text(color = \"white\"),\n                legend.title = element_text(color = \"white\"),\n                axis.title = element_text(color = \"white\"),\n                            plot.title = element_text(color = \"white\", size = 12, face = \"bold\", family = \"Times New Roman\", hjust = 0.5),\n            axis.ticks.length = unit(-0.05, \"in\"),\n            axis.text.y = element_text(margin=unit(c(0.3,0.3,0.3,0.3), \"cm\")),\n            axis.text.x = element_text(margin=unit(c(0.3,0.3,0.3,0.3), \"cm\")),\n            axis.ticks.x = element_blank(),\n            # aspect.ratio = 1,\n            plot.background = element_blank(),\n            panel.grid = element_blank(),\n            panel.border = element_blank(),\n            legend.background = element_blank(),\n        legend.position = (\"right\"))+\n  scale_color_manual(name = \"depth\", values = depth.colors)\n\np3\n```\n:::\n\n\n\n\n-->\n\n\n## Side notes\n\nI worked with *Wolbachia* in my bachelor thesis - everyone who knows them should be aware of their incredible evolution. I looked for them out of curious in the dataset, and found an entry in [`Prok_taxadata.txt`](https://github.com/InaMariaDeutschmann/GlobalNetworkMalaspinaHotmix/blob/main/00_Tables/Prok_taxdata.txt). In terms of network analysis, it will be extremely interesting to do a meta analysis on interaction between *Wolbachia* and their hosts, as well as those among their hosts and among themselves, considering the frequently occurring horizontal transfer (host switch) and gene recombination. Although this will probably be insanely complex since they are capable of so many things.\n\nNo comments on this one here since they are not included in quality-controlled ASV dataset, so it probably came from by-catch of their hosts (I wonder which) or contamination. But after I read the paper [@parvathi2020] which found *Wolbachia sp.* being most abundant in deep-sea sediment microbial community, I would literally not be surprised anymore if people found *Wolbachia* being most dominant in the aerosol of high-sky for next. They are EVERYWHERE.\n\nBy the way, our *Wolbachia* - *Altica lythri* project is aiming for another publication in the near future. Stay tuned. See @rohlfing2024 for the latest publication.\n\n\n## Reference\n\n::: {#refs}\n:::\n\n::: {.callout-caution appearance=\"minimal\" style=\"font-sze:0.9rem; border-left: none; border: 1px solid var(--clcolor);\" collapse=\"true\"}\n\n## [R session and R packages]{.cl-title}\n\n\n\n\n### R session \n<hr>\nR version 4.4.1 (2024-06-14)\nPlatform: aarch64-apple-darwin20\nRunning under: macOS 15.2\n\nMatrix products: default\nBLAS:   /Library/Frameworks/R.framework/Versions/4.4-arm64/Resources/lib/libRblas.0.dylib \nLAPACK: /Library/Frameworks/R.framework/Versions/4.4-arm64/Resources/lib/libRlapack.dylib;  LAPACK version 3.12.0\n\nlocale:\n[1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8\n\ntime zone: Europe/Berlin\ntzcode source: internal\n\nattached base packages:\n[1] stats     graphics  grDevices utils     datasets  methods   base     \n\nother attached packages:\n [1] furrr_0.3.1           future_1.34.0         geomtextpath_0.1.4   \n [4] ggpubr_0.6.0          bipartite_3.0.0.1     sna_2.8              \n [7] network_1.19.0        statnet.common_4.10.0 vegan_2.6-8          \n[10] lattice_0.22-6        permute_0.9-7         lubridate_1.9.3      \n[13] forcats_1.0.0         stringr_1.5.1         dplyr_1.1.4          \n[16] purrr_1.0.2           readr_2.1.5           tidyr_1.3.1          \n[19] tibble_3.2.1          ggplot2_3.5.1         tidyverse_2.0.0      \n[22] knitr_1.48            rmarkdown_2.28        pacman_0.5.1         \n\n\n### Packages \n<hr>\n\n\n#### bipartite\n\n\nVersion: 3.0.0.1 \n\nDormann C, Fruend J, Bluethgen N, Gruber B (2009). \"Indices, graphs and\nnull models: analyzing bipartite ecological networks.\" _The Open\nEcology Journal_, *2*, 7-24.\n\nDormann C, Gruber B, Fruend J (2008). \"Introducing the bipartite\nPackage: Analysing Ecological Networks.\" _R News_, *8*(2), 8-11.\n\nDormann C (2011). \"How to be a specialist? Quantifying specialisation\nin pollination networks.\" _Network Biology_, *1*(1), 1-20.\n\n\n#### furrr\n\n\nVersion: 0.3.1 \n\nVaughan D, Dancho M (2022). _furrr: Apply Mapping Functions in Parallel\nusing Futures_. R package version 0.3.1,\n<https://CRAN.R-project.org/package=furrr>.\n\n\n#### geomtextpath\n\n\nVersion: 0.1.4 \n\nCameron A, van den Brand T (2024). _geomtextpath: Curved Text in\n'ggplot2'_. R package version 0.1.4,\n<https://CRAN.R-project.org/package=geomtextpath>.\n\n\n#### ggpubr\n\n\nVersion: 0.6.0 \n\nKassambara A (2023). _ggpubr: 'ggplot2' Based Publication Ready Plots_.\nR package version 0.6.0, <https://CRAN.R-project.org/package=ggpubr>.\n\n\n#### knitr\n\n\nVersion: 1.48 \n\nXie Y (2024). _knitr: A General-Purpose Package for Dynamic Report\nGeneration in R_. R package version 1.48, <https://yihui.org/knitr/>.\n\nXie Y (2015). _Dynamic Documents with R and knitr_, 2nd edition.\nChapman and Hall/CRC, Boca Raton, Florida. ISBN 978-1498716963,\n<https://yihui.org/knitr/>.\n\nXie Y (2014). \"knitr: A Comprehensive Tool for Reproducible Research in\nR.\" In Stodden V, Leisch F, Peng RD (eds.), _Implementing Reproducible\nComputational Research_. Chapman and Hall/CRC. ISBN 978-1466561595.\n\n\n#### pacman\n\n\nVersion: 0.5.1 \n\nRinker TW, Kurkiewicz D (2018). _pacman: Package Management for R_.\nversion 0.5.0, <http://github.com/trinker/pacman>.\n\n\n#### rmarkdown\n\n\nVersion: 2.28 \n\nAllaire J, Xie Y, Dervieux C, McPherson J, Luraschi J, Ushey K, Atkins\nA, Wickham H, Cheng J, Chang W, Iannone R (2024). _rmarkdown: Dynamic\nDocuments for R_. R package version 2.28,\n<https://github.com/rstudio/rmarkdown>.\n\nXie Y, Allaire J, Grolemund G (2018). _R Markdown: The Definitive\nGuide_. Chapman and Hall/CRC, Boca Raton, Florida. ISBN 9781138359338,\n<https://bookdown.org/yihui/rmarkdown>.\n\nXie Y, Dervieux C, Riederer E (2020). _R Markdown Cookbook_. Chapman\nand Hall/CRC, Boca Raton, Florida. ISBN 9780367563837,\n<https://bookdown.org/yihui/rmarkdown-cookbook>.\n\n\n#### tidyverse\n\n\nVersion: 2.0.0 \n\nWickham H, Averick M, Bryan J, Chang W, McGowan LD, Fran√ßois R,\nGrolemund G, Hayes A, Henry L, Hester J, Kuhn M, Pedersen TL, Miller E,\nBache SM, M√ºller K, Ooms J, Robinson D, Seidel DP, Spinu V, Takahashi\nK, Vaughan D, Wilke C, Woo K, Yutani H (2019). \"Welcome to the\ntidyverse.\" _Journal of Open Source Software_, *4*(43), 1686.\ndoi:10.21105/joss.01686 <https://doi.org/10.21105/joss.01686>.\n\n\n#### vegan\n\n\nVersion: 2.6.8 \n\nOksanen J, Simpson G, Blanchet F, Kindt R, Legendre P, Minchin P,\nO'Hara R, Solymos P, Stevens M, Szoecs E, Wagner H, Barbour M, Bedward\nM, Bolker B, Borcard D, Carvalho G, Chirico M, De Caceres M, Durand S,\nEvangelista H, FitzJohn R, Friendly M, Furneaux B, Hannigan G, Hill M,\nLahti L, McGlinn D, Ouellette M, Ribeiro Cunha E, Smith T, Stier A, Ter\nBraak C, Weedon J (2024). _vegan: Community Ecology Package_. R package\nversion 2.6-8, <https://CRAN.R-project.org/package=vegan>.\n",
    "supporting": [
      "raftmediterranean-microbiome_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-in-header": [
        "<link href=\"../../site_libs/pagedtable-1.1/css/pagedtable.css\" rel=\"stylesheet\" />\n<script src=\"../../site_libs/pagedtable-1.1/js/pagedtable.js\"></script>\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}