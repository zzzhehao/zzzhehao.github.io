{
  "hash": "9ef8266095afefe5c56d192725dad56c",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: Community Ecology 1 - NMDS, PERMDISP and PERMANOVA\ndate: \"2024-06-29\"\ndraft: true\n---\n\n::: {.cell}\n\n```{.r .cell-code}\nlizards <- readRDS(\"biology-research/community-ecology/assets/data/jornada.lizard.rds\")\n```\n:::\n\n\n\n\n\nThis post arranges and summarises the practical part \"betapart\" and \"community metrics\" from the course _Community Ecology_. \n\n## The problem\n\nWe have multidimensional data in ecology, almost always, and they are huge. Since an n-dimensional data requires an n-dimensional space to be 1:1 displayed, if we want to have at least an overview, we need to reduce dimensions. \n\nFor example, we have a species abundance data that can be used for describing the difference between communities. What if we have additional habitat data from each community and we want to find out which environmental condition is effecting the community composition? There's a few technics can help us answer these questions, which are called as **Multi Dimensional Scaling (MDS)**, the widely used metric MDS is PCoA and its special type PCA when calculating euclidean distance.\n\n## What is NMDS?\n\nThe **Non-metric MultiDimensional Scaling (NMDS)** is, as its name implicates, the MDS for non-metric data. Which can be more convenient in analyzing ecology data, since the ecological data often don't follow the normal distribution. \n\nAs [Wikipedia](https://en.wikipedia.org/wiki/Multidimensional_scaling#:~:text=of%20the%20dissimilarities.-,Non%2Dmetric%20multidimensional%20scaling%20(NMDS)) explains, the NMDS finds a non-parametric monotonic relationship between the dissimilarities in the item-item matrix and the Euclidean distance between items, and the location of each item in the low-dimensional space.\n\nTranslate this into simplified language, it says the NMDS ...\n\n-   highlights the similarities between samples of multidimensional measurements.\n-   reduces the dimensions of the multidimensional data, but the number of dimensions are predefined, in contrast to PCA and PCoA, which always show the most important two axes.\n-   analyses distance matrix, which is commonly a dissimilarity distance matrix.\n-   is a visualization method, it has thus less precision and much less accountability for further usage of the analysis result in compare to the PCA. For a statistical assessment, additional tests regarding to particular hypothesis must be performed, and that's why we are combining NMDS with PERMANOVA.\n-   uses a rank based approach (which makes NMDS a non-metric technic), this rank is maintained consistent while reducing dimensions (monotonic).\n-   is an iterative algorithm, which use stress values to guide the iteration (see `?metaMDS` Details#4). NMDS tries to improve the iteration by randomly choosing starting point.\n\n### Stress\n\nThe inconsistency between the original high-dimensional data and the reduced low-dimensional data is measured by **stress** in each iteration. The value ranges from 0 to 1, where 0 means a _perfecto_ fit and 1 means a _big yikes_.\n\nGenerally, stress values below 0.2 are considered acceptable, below 0.1 are good. The stress value should be reported with NMDS while publishing results.\n\nHigher number of samples often leads to higher stress value, also a very low stress value might indicate that the dataset is too small for the NMDS.\n\n## Getting started\n\n```r\n#| label: setup\n#| echo: false\n#| output: false\n#| warning: false\n#| message: false\nlibrary(dplyr)\nlibrary(vegan)\nlibrary(magrittr)\npacman::p_load(c(\"tidyverse\", \"rmarkdown\", \"knitr\"), character.only = TRUE)\npath <- \"/Users/hu_zhehao/Library/Mobile Documents/com~apple~CloudDocs/Files/Obsidian/Cafe AgX HQ 2.0/004 Notes/M.Sc. Biology/Community Ecology\"\nknitr::opts_knit$set(root.dir=path) # Use proj wd (effects from next)\nknitr::opts_chunk$set(fig.align = 'center')\nsetwd(path)\ngetwd()\n```\n\nWe will use the `metaNDS()` from package `vegan` to calculate NMDS and visualize the result using `ordiplot()`. As demonstration, we use a tadpole abundance data collected in a Madagascan rain forest:\n\n```r\ngetwd()\nsource(\"ProjectAnalysis/Data_Manipulation/tadpole_clean.R\")\ntadpoleSp <- tadpoleSp[, -1] # drop first column (transects)\n```\n\n```r\ndim(tadpoleSp)\nstr(tadpoleSp[, c(1:6)]) # only showing the first 6 species\n```\n\n## Running NMDS\n\nThe `metaMDS` has an argument `autotransform` defaults to TRUE, which arbitrarily transforms data if they exceeded certain sizes. However, the transformation should better be done independently.\n\n```r\ntadNMDS <- metaMDS(tadpoleSp, k=2, autotransform = FALSE)\n```\n\nThe code above will print out stress values from each iteration. The result with the least stress value can also be called out afterwards:\n\n```r\ntadNMDS\n```\n\n## Visualizing NMDS\n\n`ordiplot` is a function specialized on visualizing ordination result from `vegan`. We can control the representation of sites or species easily using `type` and `display` argument. A simple plot with points will look like this:\n\n```r\nordiplot(tadNMDS, type = \"p\")\n```\n\nor with the site displayed in their numbers:\n\n```r\nordiplot(tadNMDS, type = \"p\", display = \"species\")\norditorp(tadNMDS, display = \"site\") # orditorp plots text by default\n```\n\n### Fitting environmental data using `vegan`\n\nAvailable environmental data could be combined with NMDS to identify potential driver in the community composition and help explain their clustering patterns.\n\n```r\nstr(env[, c(1:6)]) # only showing the first 6 variables\n```\n\nThe two variable I'm showing here are both continuous, which will automatically result a 3d-representation, those are the two axes from NMDS and the third axis showing the environmental variable. Since we only have two dimensions, the third variable is represented as a projection of the 3d-surface. We use `ordisurf` here to fit a smooth surface to the environmental data, which calls `gam()` (generalized additive model) in the background (I might get back to this with more detailed explanation in the future). \n\n```r\ndepth <- env.comp$`Depth (cm)`\n\npar(mfrow = c(1,2))\nordiplot(tadNMDS, type = \"p\", display = 'species', ylim = c(-1, 1), xlim = c(-0.5, 1))\norditorp(tadNMDS, display = \"site\", add = TRUE)\nordisurf(tadNMDS, depth, main = 'Depth', col = 'darkgreen', add = TRUE)\n\naltitude <- env.comp$`altitude [m asl]`\n\nordiplot(tadNMDS, type = \"p\", display = 'species', ylim = c(-1, 1), xlim = c(-0.5, 1))\norditorp(tadNMDS, display = \"site\", add = TRUE)\nordisurf(tadNMDS, altitude, main = 'Altitude', col = 'blue', add = TRUE)\n```\n\n### Plotting NMDS using `ggplot2`\n\nIf you have ever worked with `ggplot2` and its enormous family, you probably can't go back to basic R plots. Fortunately, there's a way to plot, not only the NMDS, also other ordination analyses from `vegan` using `ggplot2`. This can make our plot more precise and customizable.\n\n```r\nlibrary(ggplot2)\n```\n\nWe continue with the already available NMDS result from earlier, which is stored inside `tadNMDS`. The only thing we need to do, is to extract the coordinates from the points we want to plot, and then apply them in a ggplot-way. \n\n```r\ntheme_aes <- function(base_family = \"serif\", ...){\n  theme_bw(base_family = base_family, ...) +\n    theme(\n      plot.title = element_text(size = 12),\n      axis.ticks.length = unit(-0.05, \"in\"),\n      axis.text.y = element_text(margin=unit(c(0.3,0.3,0.3,0.3), \"cm\")),\n      axis.text.x = element_text(margin=unit(c(0.3,0.3,0.3,0.3), \"cm\")),\n      axis.ticks.x = element_blank(),\n      aspect.ratio = 1,\n      legend.background = element_rect(color = \"black\", fill = \"white\"),\n      panel.background = element_rect(fill = \"grey98\", colour = \"grey50\")\n    )\n} # theme modified from original by https://www.usgs.gov/\n\nlibrary(MoMAColors)\nMoMAColor <- function(clp = \"Klein\"){\n  # list(scale_color_manual(values = moma.colors(clp)),\n  # scale_fill_manual(values = moma.colors(clp)))\n  cl <- c('#8191A6', '#1A261C', '#7C8C04', '#D93D04', '#BF9B7A')\n  list(scale_color_manual(values = cl),\n  scale_fill_manual(values = cl))\n}\n\nplt <- c('#03738C', '#F2D479', '#F29F05', '#F27405', '#BF2604', '#590202')\n\nzhehaoColor <- function(colorcodes, n) {\n  color_ramp <- colorRampPalette(colorcodes)\n  return(color_ramp(n))\n}\n```\n\n```r\n# extract NMDS scores\nsiteCoord <- as_tibble(scores(tadNMDS)$sites)\nspCoord <- as_tibble(scores(tadNMDS)$species)\n\np.NMDS.sp <- ggplot()+\n  coord_equal() +\n  theme_aes() + # set themes, available in source code Rmd\n  MoMAColor() + # use MoMA color palattes, available in source code Rmd\n  theme(aspect.ratio = 1) +\n  geom_point(data = spCoord, aes(x = NMDS1, y = NMDS2), size = 2, shape = 3, color = \"red\", alpha = 0.9) +\n  ylim(-1.6, 2)\n\np.NMDS.sp.st <- p.NMDS.sp +\n  geom_point(data = siteCoord, aes(x = NMDS1, y = NMDS2), color = \"#222222\", size = 3.5, alpha = 0.5) +\n  geom_text(data = siteCoord, aes(x = NMDS1, y = NMDS2, label = c(1:nrow(siteCoord))), color = \"white\", size = 1.8, alpha = 1, check_overlap = T)\n\np.NMDS.sp.st\n```\n\nFitting environmental data with ggplot could be a bit complex. First we need to manually apply those on our NMDS:\n\n```r\nen <- envfit(tadNMDS, env.comp[, c(3:7, (ncol(env.comp)-10):ncol(env.comp))], permutation = 0, na.rm = T) # only fitting a subset of the data\nen\n```\n\n`envfit` distinguishes the variables into *vectors* (continuous) or *factor* (categorical) variables. For each category (in each categorical variable), the centroid coordinates was calculated, which represents the center of the mass and the average coordination of all points belong to that category.\n\nThe five vector variables are self-explained, `Speed_cat` represents the proportion of fast stream inside the sampled transect in five categories, e.g. a transect in which 74% of itself has fast stream is put in the category [70,80).\n\n#### Spider plot\n\nThe centroids can be used to plot a spider plot:\n\n```r \ncat <- \"speed_cat\"\ncats <- row.names(en$factors$centroids)\ncatlvl <- cats[which(str_detect(cats, regex(str_c(\"^\",cat, collapse = \"\"))))]\n\ncentroids <- as_tibble(en$factors$centroids) %>% mutate(cat = cats)\ncentroids %<>% .[which(centroids$cat %in% catlvl),]\n\nstr_sub(catlvl, start = 1, end = nchar(cat)) <- '' # fix envfit rownames and extract categories \nstr_sub(centroids$cat, start = 1, end = nchar(cat)) <- ''\n\nsegs <- left_join( \nas_tibble(cbind(siteCoord, cat = factor(env.comp[[cat]]))),\nas_tibble(setNames(centroids, c(\"cN1\", 'cN2', 'cat')))\n) # prepare geom_segment data \n\np.NMDS.sp.st_Speed <- p.NMDS.sp + \ngeom_point(data = siteCoord, aes(x = NMDS1, y = NMDS2, color = segs$cat), size = 3.5, alpha = 0.8) +\ngeom_segment(data = segs, aes(x = NMDS1, y = NMDS2, xend = cN1, yend = cN2, shape = cat, color = cat)) + # lines \ngeom_point(data = centroids, aes(x = NMDS1, y = NMDS2, shape = cat, color = cat), size = 4) + # centroid points \ngeom_text(data = siteCoord, aes(x = NMDS1, y = NMDS2, label = c(1:nrow(siteCoord))), color = \"white\", size = 1.8, alpha = 1, check_overlap = T) + \nguides(color = guide_legend(\"Fast stream percentage\"), shape = \"none\") \n\np.NMDS.sp.st_Speed \n``` \n\n#### Hull plot \n\nSometimes another hull plot will give a better overview: \n\n```r \nchullBorder <- function(site, cat) { # extract outline points \n  site <- cbind(site, cat) %>% group_by(cat) \n\n  borders <- site %>% \n    group_map(~ chull(.[, c(1,2)])) # extract outline points index \n\n  hulls <- map2(.x = borders, .y = split(site, site$cat), function(x, y){ \n    return(y[x,c(1,2)]) \n  }) %>% \n    map2_dfr(., seq_along(.), ~ mutate(.x, cat = factor(.y))) # prepare geom_polygon data \n} \n\nhulls <- chullBorder(siteCoord, env.comp[[cat]]) \n\np.NMDS.sp.st_Speed <- p.NMDS.sp + \n  geom_polygon(data = hulls, aes(x = NMDS1, y = NMDS2, fill = cat), alpha = 0.3) + # hull \n  geom_point(data = siteCoord, aes(x = NMDS1, y = NMDS2, color = env.comp$Speed_cat), size = 3.5, alpha = 0.8) + \n  guides(color = guide_legend(\"Fast stream percentage\"), fill = \"none\") \n\np.NMDS.sp.st_Speed \n``` \n\n```r \nsummary(env.comp$`stream slope [cm/30m]`) \nslope_hulls <- chullBorder(siteCoord, env.comp$slope_cat) \n\np.NMDS.sp.st_slope <- p.NMDS.sp + \n  geom_polygon(data = slope_hulls, aes(x = NMDS1, y = NMDS2, fill = cat), alpha = 0.3) + # hull \n  geom_point(data = siteCoord, aes(x = NMDS1, y = NMDS2, color = env.comp$slope_cat), size = 3.5, alpha = 0.8) + \n  guides(color = guide_legend(\"Fast stream percentage\"), fill = \"none\") \n\np.NMDS.sp.st_slope \n``` \n\n```r \nsummary(env.comp$`stream slope [cm/30m]`) \nslope_hulls <- chullBorder(siteCoord, env.comp$slope_cat) \n\np.NMDS.sp.st_slope <- p.NMDS.sp + \n  geom_polygon(data = slope_hulls, aes(x = NMDS1, y = NMDS2, fill = cat), alpha = 0.3) + # hull \n  geom_point(data = siteCoord, aes(x = NMDS1, y = NMDS2, color = env.comp$slope_cat), size = 3.5, alpha = 0.8) + \n  guides(color = guide_legend(\"Fast stream percentage\"), fill = \"none\") \n\np.NMDS.sp.st_slope \n``` \n\n\n\n#### Continuous variable: fitting surface \n\nTo fit a smooth surface on our data, we still use `ordisurf` from `vegan` to do the calculation, but we do not let it plot the result directly.  \n\n```r \ndepth <- ordisurf(tadNMDS ~ env.comp$`Depth (cm)`, plot = FALSE) \nalt <- ordisurf(tadNMDS ~ env.comp$`altitude [m asl]`, plot = FALSE) \nslope <- ordisurf(tadNMDS ~ env.comp$`stream slope [cm/30m]`, plot = FALSE) \n``` \n\nAs I mentioned before, the environmental variable of the surface is stored in the third axis, if we take look at the ordination object `ordisurf` produces (try `str(depth)`, I will not show it here since it is a very huge object), we can find a `$grid` list containing all the coordinates. We simply need to extract them and plot them on our ggplots. \n\n```r \nextract.xyz <- function(obj) { \n  xy <- expand.grid(x = obj$grid$x, y = obj$grid$y) \n  xyz <- cbind(xy, c(obj$grid$z)) \n  names(xyz) <- c(\"x\", \"y\", \"z\") \n  return(xyz) \n} \n\ncontour.depth <- extract.xyz(obj = depth) \ncontour.alt <- extract.xyz(obj = alt) \ncontour.slope <- extract.xyz(obj = slope) \n``` \n\n`geom_textcontour` from package `geomtextpath` can easily make a nice ggplot-layer of the surface contour. We can then combine all plots together and have our final plot: \n\n```r \nlibrary(geomtextpath) \np.NMDS.sp.st.depth <- p.NMDS.sp.st + \n  geom_textcontour(data = contour.depth, aes(x, y, z = z), color = moma.colors(\"OKeeffe\")[2]) + \n  geom_text(aes(-0.25, 1.75, label = \"Depth\"), size = 7, fill = \"black\", fontface = \"bold\") \n\np.NMDS.sp.st.alt <- p.NMDS.sp.st + \n  geom_textcontour(data = contour.alt, aes(x, y, z = z), color = moma.colors(\"OKeeffe\")[3]) + \n  geom_text(aes(-0.25, 1.75, label = \"Altitude\"), size = 7, fill = \"black\", fontface = \"bold\") + \n  ylab(\"\") \n\np.NMDS.sp.st.slope <- p.NMDS.sp.st + \n  geom_textcontour(data = contour.slope, aes(x, y, z = z), color = moma.colors(\"OKeeffe\")[5]) + \n  geom_text(aes(-0.25, 1.75, label = \"Stream slope\"), size = 7, fill = \"black\", fontface = \"bold\") \n\n# include speed plot \np.NMDS.sp.st_Speed <- p.NMDS.sp.st_Speed +  \n  guides(color = \"none\", fill = \"none\") + \n  geom_text(aes(-0.25, 1.75, label = \"Fast stream percentage\"), size = 7, fill = \"black\", fontface = \"bold\") + \n  ylab(\"\") \n\n# arrange \nlibrary(ggpubr) \np.NMDS.sp.st.fit <- ggarrange( \n  p.NMDS.sp.st.depth, p.NMDS.sp.st.alt, p.NMDS.sp.st.slope, p.NMDS.sp.st_Speed,  \n  ncol = 2, nrow = 2, \n  align = \"hv\") \n\np.NMDS.sp.st.fit \n``` \n\n`geom_contour_filled` can also filled up the space between surface levels and make fancier plots, but it is more often used in visualizing meteorological data (maybe see `metR` ?). \n\n```r \np.NMDS.sp.st.depth <- ggplot(data = spCoord, aes(x = NMDS1, y = NMDS2))+ \n  geom_contour_filled(data = contour.depth, aes(x, y, z = z), alpha = 0.9) + \n  geom_point(data = spCoord, aes(x = NMDS1, y = NMDS2), size = 2, shape = 3, color = \"red\", alpha = 1) + \n  geom_point(data = siteCoord, aes(x = NMDS1, y = NMDS2), color = \"#222222\", size = 3.5, alpha = 0.5) + \n  geom_text(data = siteCoord, aes(x = NMDS1, y = NMDS2, label = c(1:nrow(siteCoord))), color = \"white\", size = 1.8, alpha = 1, check_overlap = T) + \n  scale_fill_manual(values = zhehaoColor(plt, 20)) + \n  coord_equal() + \n  theme_aes() + # available in source code Rmd \n  theme(aspect.ratio = 1, legend.position = \"none\") + \n  ylim(-1.6, 2)  \n  # geom_text(aes(-0.35, 1.75, label = \"Depth\"), size = 8, fill = \"black\", fontface = \"bold\") \n\np.NMDS.sp.st.depth \n``` \n\n### What matters? \n\nNow, as we have all these fancy plots, let's talk about what we can interpret from them.  \n\nFirst, we noticed that there are two variables showing **planar** surfaces: the altitude and the stream slope. The consistent parallel surface contour shows that these two variables change at a constant rate (consistent gradient) across the NMDS space, also means the relationships between these variables and the NMDS axes are linear. \n\n- *OK, but what does that even mean?* \n\nThe interpretation of a planar surface in NMDS can be tricky. The consistent gradient itself indicates a smooth transition of that environmental condition through our studied communities, this is possibly the case for altitude. But do these gradients explain the variation in our community? We have to dive a bit deeper to answer that question. And here comes PERMANOVA to the game. \n\n## PERMANOVA \n\n**PERmutational Multivariate ANalysis of VAriance (PERMANOVA)** is w \n\n@bakker2024 explained PERMANOVA test and @bakker2024a explained PERMDISP \n\n```r \nalt <- env.comp$`altitude [m asl]` \nslope <- env.comp$`stream slope [cm/30m]` \ndep <- env.comp$`Depth (cm)` \nspeed <- env.comp$speed_cat \n\nadonis2(tadpoleSp ~ alt*slope*dep*speed)  \n  # adonis2(tadpoleSp ~ slope*dep*Speed_cat) \n# adonis2(tadpoleSp ~ env.comp$`altitude [m asl]`* env.comp$`stream slope [cm/30m]`* env.comp$`Depth (cm)`* env.comp$Speed_cat) \n# adonis2(tadpoleSp ~ env.comp$`stream slope [cm/30m]`* env.comp$`Depth (cm)`* env.comp$Speed_cat) \n\n# adonis2(tadpoleSp ~ env.comp$`Depth (cm)`* env.comp$Speed_cat) \n# adonis2(tadpoleSp ~ env.comp$`stream slope [cm/30m]`* env.comp$Speed_cat) \n# adonis2(tadpoleSp ~ env.comp$Speed_cat) \n``` \n\n```r \nlibrary(betapart) \ndist <- beta.pair.abund(tadpoleSp, index.family = \"bray\") \nperm <- betadisper(dist[[3]], env.comp$speed_cat) # a multivariate analogue of Levene's test for homogeneity of variances \nanova(perm) \n``` \n\n\n## Acknowledgement\n\nI hereby express my thanks to the codes and examples shared by \n\n- [Dr. Jackie Zorz](https://jkzorz.github.io/2020/04/04/NMDS-extras.html)\n- [Dr. Christopher Chizinski](https://chrischizinski.github.io/rstats/vegan-ggplot2/)\n- [Allan Cameron](https://stackoverflow.com/a/75507179/24065650)\n\nfor helping me finish this post.\n\n---\n\n**Issues? Comments? Improvements?** I'm happy to hear your opinions on this post and my website. Find my source code at [github](https://github.com/zzzhehao/zzzhehao.github.io/tree/main) or [contact me](mailto:hu_zhehao@hotmail.com).\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}