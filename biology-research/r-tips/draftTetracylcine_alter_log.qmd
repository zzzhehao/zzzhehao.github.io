---
title: Änderung Tetracycline.R
lightbox: true
eval: false
---

Ich beschreibe hier wie man in R data wrangling macht, dann kannst du deine .xlsx so verändern wie du willst, alle was du dann tun musst ist einfach das Skript anpassen.

Package laden:

```{r}
#| output: false
library(readxl)
library(ggpubr)
library(ggsignif)
library(rstatix)
library(broom)
```

```{r}
# tidyverse ist wie ein package von packeges
library(tidyverse)
```

Wir nutzen keine maskierte Funktionen, deswegen ist die Warnung hier kein Problem. Als wir `tidyverse` als letzte laden, überwältigt seine Funktion alle anderen. Wenn man die andere Funktion braucht, kann man immer mit `rstatix::filter()` spezifizieren.

Daten importieren:

```{r}
raw <- read_xlsx("marla_ditzer_bachelorthesis_data.xlsx", sheet = "Tetracycline ", range = "A3:N71") %>% 
    filter(!is.na(Group) & !is.na(GI_ID))
```

Mit `sheet = "Tetracycline "` laden wir spezifisch den Tetracycline Datenblatt (Name muss identisch sein), wenn nichts angegeben, die Funktion lädet einfach das erste. Dies ist dann optional wenn das gewünschte Datenblatt einfach der erste ist. `range = "A3:N71"` definiert welche Zellen in den Datenblatt zu laden, ich habe es hier an deiner Datei angepasst, sollte später mehr Daten dazu kommen, muss das angepasst werden.

`filter` behält nur die Zeilen, die die Bedingung erfüllt. `is.na()` gibt `TRUE` zurück wenn ein Wert NA ist. Mit `!` habe ich den Wert negiert. Also hier schmeiße ich alle Zeilen ohne Angabe in der Spalte `Group` und `Gl_ID` weg. 

`%>%` gibt das Ergebnis von der vorherigen Funktion nach hintern weiter (heißt daher "pipe").

Dann wollen wir bisschen data wrangling machen:

```{r}
#| warning: false
colnames(raw)[which(names(raw) == "Initial Target Copies")] <- "quantity"
```

Wir nennen die Spalte `Initial Target Copies` zu `quantity` um. Vorher hab ich hier direkt mit index (die Position der Spalte) spezifiziert, jetzt lasse ich das Programm selber rausfinden wo diese Spalte ist. Dann kannst du die Spalte in EXCEL beliebig einordnen, das Programm findet das immer, solange der Name übereinstimmt.

Mir ist auch eingefallen, dass die Spalte bei dir `GI_ID` statt `Gl_ID` genannt ist (sorry für meine Benennung). Das kannst du entweder in EXCEL ändern oder einfach hier ein extra Zeil schreiben:

```{r}
#| warning: false
colnames(raw)[which(names(raw) == "GI_ID")] <- "Gl_ID"
```

Dann noch ein paar Bearbeitung: 

```{r}
raw <- raw %>% 
    mutate( 
        quantity = as.numeric(quantity), # <1>
        Interpretation = case_when( # <2>
            `Suggest result` == "Negative" ~ "negative", # <3>
            `quantity` == "Positive" ~ "positive", # <4>
        )) %>%
    mutate(Interpretation = replace(Interpretation, is.na(Interpretation), "quantified")) %>% # <5>
    mutate(
        Interpretation = factor(Interpretation), # <6>
        Haplotype = factor(Haplotype), # <6>
        Group = factor(Group)) # <6>
```

1. <= clicken für Code Highlight) `mutate()` erzeugt neue Spalte in data.frame. `quantity` haben wir im letzten Schritt schon definiert, daher wird hier die alte Spalte ersetzt. `as.numeric(quantity)` definiert die Datentyp der Spalte als numerisch. Diese Spalte wurde als `character`, also reine Texten anerkannt, obwohl sie eigentlich Zahlen sind. Es sei denn man hat das in EXCEL als Nummer formatiert. 
2. Neue Spalte `Interpretation`, wir weisen unter verschiedene Bedingung verschiedene Werte zu
3. Wenn `Suggest result` "Negative" ist, dann ist `Interpretation` auch "negative"
4. Mein anderer Programm spuckt unquantifizierbare positive Proben mit "Positive" in `Initial Target Copies`, welche jetzt `quantity` heißt. Dies ist der Fall wenn mehrere Tm vorhanden sind, dann sind die Quantifizierung nicht mehr genau und soll nicht vergleicht werden. Solche Proben wollen wir bei Interpretation als "positive" bemerken. Wenn nichts von den beiden abstimmt, NA wird zugewiesen. Deien Daten hier sind sehr sauber, daher keine "Positive".
5. Der Rest (NA) ist quantifizierbare Proben, `replace()` ersetzt die NA mit "quantified".
6. Wir verändern diese Spalten als `factor`, heißt sie sind categorische Variablen.

Mit `str()` kann man die Struktur, i.e. eine Liste über den Spalten der Datensatz sehen, da wird jeweiligen Datentyp auch angezeigt. 

```{r}
str(raw)
```

Wir sehen bei `Haplotyp`, es gibt Proben die als "Ht2" statt "HT2" angegeben sind, diese werden von R separat behandelt, so können wir das korrigieren:

```{r}
raw$Haplotype[raw$Haplotype == "Ht2"] <- "HT2"
```

`raw$Haplotype` wählt die angegebene Spalte aus, `[raw$Haplotype == "Ht2"]` wählt die Zeile aus, die diese Bedingung erfüllt.

Jetzt können wir die quantifizierbare Proben aus dem Datensatz extrahieren:

```{r}
r.quantified <- raw %>%
    filter(Interpretation == "quantified" & !is.na(Haplotype) & !is.na(Group)) 
```

<br>

## Statistische Tests

Diesen Teil hab ich wahrscheinlich noch nie mit dir geschnackt. Ich hatte etwas Schwierigkeit am Anfang alles nachzuvollziehen, deswegen erläutere ich hier bisschen mehr, falls du das auch lesen magst. Ich wurde so beigebracht, wenn man den Unterschied oder die Korrelation testen möchte, überprüft man immer die Normalität als erste, weil viele Tests die Normalverteilung der Daten als Voraussetzung annehmen. 

```{r}
shapiro_result <- r.quantified %>% 
  filter(!is.na(Haplotype)) %>% 
  group_by(Group, Haplotype) %>% # <1>
  nest() %>% # <2>
  mutate(Shapiro = map(data, ~shapiro.test(.x$quantity))) %>% # <3>
  mutate(shapiro_g = Shapiro %>% map(glance)) %>% # <4>
  unnest(shapiro_g) # <4>
```

1. Wir wollen nachher die Unterschiede zwischen Haplotyp-Behandlung Gruppen testen, daher wird die Daten doppelt gruppiert. Hier entsteht dann vier Gruppen (2 Haplotypen x 2 Behandlungen)
2. Wir ändern die Datenstruktur für nächste Funktion (`map()`), es wird bei Schritt 4 zurück gemacht.
3. Hier findet der Test statt: `shapiro.test()`
4. Die `map()`, `nest()` und `unnest()` musst du nicht unbedingt verstehen. Die sind dafür da, dass du den Test nur mit einem Code bei allen Gruppen machen kannst und das Ergebnis in einer Objekt speichern kannst:

```{r}
shapiro_result
```

Shapiro-Test nimmt an (also $H_0$), dass die Daten normal verteilt sind. D.h. wenn der p-Werte signifikant ist (p<0.05), wird die $H_0$ abgelehnt, bedeutet, die Daten sind nicht normal verteilt. Die HT1-Tetracycline Gruppe ist der Fall. 

Alternativ kann man immer den Test einzeln machen:

```{r}
r.quantified %>% filter(Haplotype == "HT1" & Group == "Tetracycline") %>% .$quantity %>% shapiro.test()
```

`.` bedeutet das über `%>%` weitergeleitete Ergebnis von vorheriger Funktion an. Das Ergebnis übereinstimmt mit vorherigen Werten.

### Unterschied testen 

Wie gesagt, viele Tests nehmen die Normalität als Voraussetzung an. Dazu zählt auch T-test, weil der T-test den Mittelwert von beiden Gruppen vergleicht. Das macht dann nur Sinn, wenn beide Gruppen normal sind. (Der Mittelwert kann nur die gesamten Datensatz sinnvoll vertreten, wenn die Verteilung normal ist) Da hier eine Gruppe nicht normal ist, aller Vergleich mit dieser Gruppe darf keine Annahme von Normalität haben.

Die Alternative ist Mann-Whitney-U-Test (eine Version des Wilcox-Tests, siehe auch Entscheidungshilfe.pdf > Unterschied > 2 Gruppe > metrisch, nicht normal > unabhängig). Unsere Daten sind unabhängig, d.h. die Daten, die zur Control gehören, sind komplett andere Stichprobe als die Daten, die zur Tetracycline gehören. Daher wird in den PDF mit `wilcox_test(paired = FALSE)` definiert, aber dies ist default bei der Funktion, muss man nicht unbedingt angeben. 

Wilcox-Test gehört zu sogenannten Non-parametric Test, d.h. der macht keine Annahme, wie die Daten aussehen sollen. Daher kann dieser Test auch für normal verteilte Daten genutzt werden. Wir wollen hier auch den Unterschied zwischen den Effekt der Behandlung in verschiedenen Haplotypen sehen, macht es deswegen mehr Sinn, die HT2 auch mit U-Test zu testen.

```{r}
stat.result <- r.quantified %>%  
    filter(!is.na(quantity)) %>%  
    group_by(Haplotype) %>% # <1>
    wilcox_test(quantity ~ Group) %>% # <2>
    add_significance() # <3>
stat.result
```

1. Wir wenden den Test separat bei jedem Haplotyp an.
2. `quantity ~ Group` bedeutet, wir machen den Test mit `quantity`, und teilen die Werte nach `Group`.
3. Die Signifikanz-Sterne einfügen. (`*`: p<0.05, `**`: p<0.01, `***`: p<0.001, `****`: p<0.0001)

## Visualisierung

```{r}
# rein Ästhetiks
cbp5 <- (c("#888888","#35CCC9")) # Antibiotic treatment

theme_USGS_box <- function(base_family = "serif", ...){
  theme_bw(base_family = base_family, ...) +
    theme(
      plot.title = element_text(size = 12),
      axis.ticks.length = unit(-0.05, "in"),
      axis.text.y = element_text(margin=unit(c(0.3,0.3,0.3,0.3), "cm")),
      axis.text.x = element_text(margin=unit(c(0.3,0.3,0.3,0.3), "cm")),
      axis.ticks.x = element_blank(),
      aspect.ratio = 1,
      legend.background = element_rect(color = "black", fill = "white"),
      panel.background = element_rect(fill = "grey96", colour = "grey20")
    )
}
```

Das Package `ggplot2` ist ein package für Datenvisualisierung in R, der hat bisschen seine "eigene" Grammatik, aber ist super powerful. 

```{r}
quantity_group.Box <- 
    r.quantified %>% # <1>
    filter(!is.na(Haplotype)) %>% # <1>
    ggplot(aes(x=Group,y=quantity)) + # <2>
        geom_boxplot(aes(fill = Group)) + # <3>
        scale_y_continuous( # <4>
            trans = scales::log10_trans()) + # <4>
        facet_grid(.~Haplotype) + # <5>
        theme_USGS_box() + # <6>
        theme( # <6>
            strip.text.x.top = element_text(face = "bold", size = 10), # <6>
            aspect.ratio = 3, # <6>
            axis.text.x = element_text(angle = 45, hjust = 1, size = 10) # <6>
        ) + # <6>
        scale_fill_manual(values = cbp5) + # <7>
        labs(x = "", y = "wsp gene copies/µg DNA", fill = "Treatment") # <8>
```

1. Vorbereitung der Daten, die wir für den Plot nutzen möchten.
2. Initialisierung einer ggplot Objekt (i.e. ein leeres Canvas). Alle weitere ggplot Code werden mit `+` hinzugefügt. Am Anfang dieser Code speichern wir die Objekt auch, sodass man später aufrufen und updaten kann.
3. Boxplot: `fill = Group` gibt an, dass die Farbe `Group` darstellt.
4. Y-Achse wird logarithmisch (log 10) skaliert.
5. Jede Haplotyp hat sein eigene "Subplot".
6. Ästhetik. Wenn du nur HT1 und HT2 hast, kannst du auch bei `aspect.ratio` etwas ändern, sodass das Bild besser in deiner Arbeit passt. In `theme()` kann man sehr viele Aussehen ändern. (Siehe `?theme()` oder [die Webseite](https://ggplot2.tidyverse.org/reference/theme.html) für mehr)
7. Die Farbe definieren.
8. Labels definieren. Hier kannst du auch `title` und `caption` angeben.

```{r}
quantity_group.Box # mal schauen wie das aussieht
```

Wir wollen noch etwas dazu zeichnen. 

```{r}
#| message: false
#| warning: false
stat.result <- stat.result %>% 
    add_xy_position(x = "Group") %>% # <1>
    mutate(y.position = log(y.position, base = 10)) # <2>

quantity_group.Box <- quantity_group.Box + # <3>
    stat_pvalue_manual(stat.result, step.increase = 0.01, size = 4, tip.length = 0.01) + # <4>
    scale_y_continuous( # <5>
        trans = scales::log10_trans(), 
        breaks = c(1e6, 5e6, 1e7, 5e7, 1e8), # <6>
        expand = expansion(mult = c(0.07,0.10))) # <7>
```

1. Wir zeigen die Signifikanz auch aufm Plot. Die Signifikanz wird von ggplot auch als ein Element behandelt (wie ein Datenpunkt), daher brauchen sie eigene x/y-Koordinaten. Die Funktion rechnet automatisch aus wo die Signifikanz sein sollen. 
2. Da unser Y-Achse logarithmisch ist, die Y-Werte anpassen.
3. Das Plot aufrufen und updaten.
4. Die P-Signifikanz anzeigen lassen.
5. Y-Achse war nicht perfekt, noch bisschen Anpassung.
6. Breaks waren komisch (3e+7 war schwer nachzuvollziehen)
7. Die Limitierung erweitern, mehr Platz für P-Signifikanz.

```{r}
quantity_group.Box
```

Vllt auch die Probenanzahl anzeigen?

```{r}
n_fun.p1 <- function(x){
  return(data.frame(y = 8.3, # <1>
                    label = length(x))) # <2>
}

quantity_group.Box <- quantity_group.Box +
    stat_summary(fun.data = n_fun.p1, geom = "text", hjust = 0.5) # <3>

```

1. Die Zahlen werden bei 1e+8.3 gezeigt
2. Diese Funktion wird gleich in ggplot Objekt aufgerufen, wo wir mit den Datensatz `r.quantified` arbeiten (haben bei Initialisierung der Objekt definiert), `x` wird dann unsere Datensatz sein, `length(x)` gibt die Länge, i.e. Anzahl der Elemente in den Datensatz, i.e. Anzahl der Zeilen (Proben) an.
3. Die Funktion anwenden.

```{r}
quantity_group.Box
```

Wenn man zufrieden ist, kann dann mit `ggsave()` speichern:

```{r}
#| eval: false

ggsave(filename = "Quantity_Group_Boxplot.png", plot = quantity_group.Box, width = 15, height = 15, units = "cm", dpi = 300)
```

## Das categorische Ergebnis aller Daten

Unten ist ein anderer Plot um zu zeigen was alle Proben für ein Ergebnis haben. Der Code ist ähnlich wie oben. 

```{r}
#| message: false
#| warning: false
category.Bar <- 
  raw %>% filter(!is.na(Haplotype)) %>%
    ggplot(aes(x = Interpretation, fill = Group))+
        geom_histogram(stat = "count", binwidth = 1500) +
        stat_count(
            binwidth = 1500, 
            geom = "text", 
            color = "white", 
            aes(label = after_stat(count), group = Group),
            size = 3.5,
            position = position_stack(vjust = 0.55)) +
        facet_wrap(vars(Haplotype)) +
        theme_USGS_box() +
        theme(
            strip.text.x.top = element_text(face = "bold", size = 10),
            legend.position = "none",
            aspect.ratio = 3,
            axis.text.x = element_text(angle = 45, hjust = 1, size = 11)
        ) +
        scale_fill_manual(values = cbp5) +
        labs(x = "", y = "Number of Observations")

category.Bar
```

Man kann auch mehrere Plots kombinieren:

```{r}
#| eval: false

combi <- ggarrange(category.Bar, quantity_group.Box, nrow = 1, labels = c("A", "B"), align = "h", widths = c(2,3)) # `widths` gibt an wie die Breite für jeden Plot zugeteilt wird

ggsave(filename = "Combi.png", plot = combi, width = 20, height = 10, units = "cm", dpi = 300)
```

![Combi.png](Combi.png)